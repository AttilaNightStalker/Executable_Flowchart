/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Nov 29 2019 18:07:44 GMT-0600 (CST).
 */

// import drawArrow from './DrawLines.js'

define(['css!./styles/FlowChartVizWidget.css'], function () {
    'use strict';

    var WIDGET_CLASS = 'flow-chart-viz';

    function FlowChartVizWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');

        this._cur_state = null;
        this.nodeElementbyId = {};
    }

    FlowChartVizWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        // Create a dummy header
        // this._el.append('<h3>FlowChartViz Events:</h3>');

        this._el.append('<canvas id="paint" width="1000" height="1000"> This text is displayed if your browser does not support HTML5 Canvas.</canvas>');

        // Registering to events can be done with jQuery (as normal)
        this._el.on('dblclick', function (event) {
            event.stopPropagation();
            event.preventDefault();
            self.onBackgroundDblClick();
        });
    };

    FlowChartVizWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    // Adding/Removing/Updating items
    FlowChartVizWidget.prototype.addNode = function (desc) {
        if (desc) {
            // Add node to a table of nodes
            // var node = document.createElement('div'),
            //     label = 'children';

            // if (desc.childrenIds.length === 1) {
            //     label = 'child';
            // }

            // this.nodes[desc.id] = desc;
            
            // node.innerHTML = 'Adding node "' + desc.name + '" (click to view). It has ' +
                // desc.childrenIds.length + ' ' + label + '.';

            // this._el.append(node);
            // node.onclick = this.onNodeClick.bind(this, desc.id);
        }
    };

    FlowChartVizWidget.prototype.removeNode = function (gmeId) {
        var desc = this.nodes[gmeId];
        // this._el.append('<div>Removing node "' + desc.name + '"</div>');
        delete this.nodes[gmeId];
    };

    FlowChartVizWidget.prototype.updateNode = function (desc) {
        if (desc) {
            this._logger.debug('Updating node:', desc);
            // this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    FlowChartVizWidget.prototype.onNodeClick = function (/*id*/) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    FlowChartVizWidget.prototype.onBackgroundDblClick = function () {
        // this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    FlowChartVizWidget.prototype.destroy = function () {
    };

    FlowChartVizWidget.prototype.onActivate = function () {
        this._logger.debug('FlowChartVizWidget has been activated');
    };

    FlowChartVizWidget.prototype.onDeactivate = function () {
        this._logger.debug('FlowChartVizWidget has been deactivated');
    };

    /******************************************************************************************************** */
    /* my functions
    /******************************************************************************************************** */
    FlowChartVizWidget.prototype.renderChart = function (nodesInfo, varInfo, varNameMap) {
        console.log("rendering chart");
        let self = this;

        self._nodesInfo = nodesInfo;
        self._varInfo = varInfo;
        self._varNameMap = varNameMap;
        self._triggerBtn = null;

        for (var id in nodesInfo) {
            var node = document.createElement('div');
            node.id = id;
            node.className = nodesInfo[id].type;
            node.style.position = 'absolute';
            node.style.display = 'block';
            node.style.left = nodesInfo[id].position.x + "px";
            node.style.top = nodesInfo[id].position.y + "px";
            node.innerHTML = nodesInfo[id].name;
            self._el.append(node);
            self.nodeElementbyId[id] = node;
            
            if (nodesInfo[id].type == 'Start') {
                self._start_point = id;
            }
        }

        for (var id in nodesInfo) {;
            var posX = nodesInfo[id].position.x;
            var posY = nodesInfo[id].position.y;
            
            for (var i = 0; i < nodesInfo[id].outFlow.length; i++) {
                let out = nodesInfo[id].outFlow[i];

                let outX = nodesInfo[out.id].position.x;
                let outY = nodesInfo[out.id].position.y;
                
                self._drawArrow(posX, posY, outX, outY, nodesInfo[id].type, nodesInfo[id].outFlow[i], nodesInfo[out.id].type);
            }
        }

        for (var id in varInfo) {
            console.log('id', id);
            var varVal = document.createElement('div');
            var varInput = document.createElement('input');
            varInput.id = id + '_input';
            varInfo[id].value = varInfo[id].default_val;
            varInput.value = varInfo[id].value;

            let span = document.createElement('span');
            span.innerHTML = varInfo[id].name + ' = ';

            varVal.id = id;
            varVal.style.position = 'absolute';
            varVal.style.display = 'block';
            varVal.style.left = varInfo[id].position.x + 'px';
            varVal.style.top = varInfo[id].position.y + 'px';

            varVal.appendChild(span);
            varVal.appendChild(varInput);

            self._el.append(varVal);
            self.nodeElementbyId[id + '_input'] = varInput;
        }

        self._triggerBtn = document.createElement('button');
        let trigger = self._triggerBtn;
        trigger.id = 'trigger';
        trigger.className = 'btn'
        trigger.style.position = 'absolute';
        trigger.style.left = '5px';
        trigger.style.top = '40px';
        trigger.innerHTML = 'trigger';
        self._el.append(trigger);
        trigger.disabled = true;

        trigger.onclick = function () {
            var curNode;
            var boolVal;

            if (self._cur_state == null) {
                self._cur_state = self._start_point;
                console.log(self._cur_state, 'start');
                curNode = self.nodeElementbyId[self._cur_state];
                curNode.style.borderColor = 'red';
                // self._el.append(curNode);

                for (var id in self._varInfo) {
                    let varValue = self.nodeElementbyId[id + '_input'].value;
                    if (self._varInfo[id].type == 'String_Var') {
                        self._varInfo[id].value = varValue;
                    }
                    else {
                        self._varInfo[id].value = eval(varValue);
                    }
                    
                    self.nodeElementbyId[id + '_input'].disabled = true;
                }
            }

            else {
                let nodeInfo = self._nodesInfo[self._cur_state];
                if (nodeInfo.type == 'Process') {
                    console.log('Process')
                    console.log(nodeInfo.func);
                    let arglist = []
                    for (var id in self._varInfo) {
                        arglist.push(self._varInfo[id].value);
                    }

                    console.log('execute process..');
                    let resDict = nodeInfo.func(...arglist);
                    console.log(resDict);

                    for (var name in resDict) {
                        let idOfName = self._varNameMap[name];
                        self._varInfo[idOfName].value = resDict[name];
                        self.nodeElementbyId[idOfName + '_input'].value = self._varInfo[idOfName].value;
                    }
                }

                else if (nodeInfo.type == 'Decision') {
                    console.log('Decision');
                    console.log(nodeInfo.func);

                    let arglist = [];
                    for (id in self._varInfo) {
                        arglist.push(self._varInfo[id].value);
                    }

                    boolVal = nodeInfo.func(...arglist);
                    console.log(boolVal);
                }

                curNode = self.nodeElementbyId[self._cur_state];
                // document.getElementById(self._cur_state).then
                curNode.style.borderColor = 'black';
                // self._el.append(curNode);

                if (nodeInfo.outFlow.length == 0) {
                    self._cur_state = null;
                    for (var id in self._varInfo) {
                        // self.nodeElementbyId[id + '_input'].disabled = false;
                        self._varInfo[id].value = self._varInfo[id].default_val;
                        self.nodeElementbyId[id + '_input'].value = self._varInfo[id].value;
                    }

                    self._triggerBtn.disabled = true;
                }

                else {
                    if (nodeInfo.type == 'Decision' && boolVal == true) {
                        self._cur_state = nodeInfo.outFlow[1].id;
                    }
                    else {
                        self._cur_state = nodeInfo.outFlow[0].id;
                    }

                    curNode = self.nodeElementbyId[self._cur_state];
                    nodeInfo = self._nodesInfo[self._cur_state];
                    
                    curNode.style.borderColor = 'red';

                    // self._el.append(curNode);

                    console.log(self._nodesInfo[self._cur_state].name);
                }
            }
        }

        var reset = document.createElement('button');
        reset.id = 'reset'
        reset.className = 'btn';
        reset.style.position = 'absolute';
        reset.style.left = '5px';
        reset.style.top = '75px';
        reset.innerHTML = 'reset';
        self._el.append(reset);

        reset.onclick = function() {

            self._triggerBtn.disabled = false;

            if (self._cur_state != null) {
                let curNode = self.nodeElementbyId[self._cur_state];
                curNode.style.borderColor = 'black';
                self._cur_state = null;
            }
        
            for (var id in self._varInfo) {
                // self._varInfo[id].value = self._varInfo[id].default_val;
                // self.nodeElementbyId[id + '_input'].value = self._varInfo[id].value;
                self.nodeElementbyId[id + '_input'].disabled = false;
            }

        }
        // console.log(this._el["0"].innerHTML);
    };


    FlowChartVizWidget.prototype.reportErrors = function(errMsg) {
        for (var i = 0; i < errMsg.length; i++) {
            console.log(i);
            let msg = document.createElement('div');
            msg.innerHTML = errMsg[i];
            msg.style.position = 'relative';
            msg.style.marginTop = '30px';
            msg.id = 'err_' + i;
            this._el.append(msg);
        }
    }

    FlowChartVizWidget.prototype._drawArrow = async function (x1, y1, x2, y2, src, trans, dst) {
        // console.log(canvasElement); }

        let L_Width = 3;
        var c = document.getElementById('paint');
        var ctx = c.getContext('2d');

        if (ctx == null) {
            return;
        }
        ctx.beginPath();
        ctx.lineWidth = L_Width;

        if (trans.type == 'PositiveTrans') {
            ctx.strokeStyle = '#1f8c0b';
        }
        else if (trans.type == 'NegativeTrans') {
            ctx.strokeStyle = '#8c0b0b';
        }
        else {
            ctx.strokeStyle = '#000000';
        }
        
        var arrowSize = 10;
        
        if (y2 - y1 > 80) {
            let fromX = x1 + 60;
            let toX = x2 + 60;
            let fromY = y1 + 60;
            let toY = y2;
            this._canvas_arrow(ctx, fromX, fromY, toX, toY);
            
            console.log("y2 - y1 > 80");

        }
        else if (x2 - x1 > 140 && y2 - y1 < 80 && y2 - y1 > -80) {
            let fromX = x1 + 120;
            let toX = x2;
            let fromY = y1 + 30;
            let toY = y2 + 30;
            this._canvas_arrow(ctx, fromX, fromY, toX, toY);
            console.log("x2 - x1 > 140");

        }
        else if (x1 - x2 > 140 && y2 - y1 < 80 && y2 - y1 > -80) {
            let fromX = x1;
            let toX = x2 + 120;
            let fromY = y1 + 30;
            let toY = y2 + 30;
            this._canvas_arrow(ctx, fromX, fromY, toX, toY);
            
            console.log("x1 - x2 > 140");
        }
        else if (x1 < x2) {
            ctx.moveTo(x1, y1 + 30);
            ctx.lineTo(x1 - 30, y1 + 30);
            ctx.lineTo(x1 - 30, y2 + 30);
            this._canvas_arrow(ctx, x1 - 30, y2 + 30, x2, y2 + 30);
        }
        else {
            ctx.moveTo(x1 + 120, y1 + 30);
            ctx.lineTo(x1 + 150, y1 + 30);
            ctx.lineTo(x1 + 150, y2 + 30);
            this._canvas_arrow(ctx, x1 + 150, y2 + 30, x2 + 120, y2 + 30);
        }
        
        console.log(x1, y1, x2, y2);
            // ctx.moveTo(x1, y1);
            // ctx.lineTo(x1, y2);
            // ctx.lineTo(x2, y2);
        
        ctx.stroke();
    }

    FlowChartVizWidget.prototype._canvas_arrow = function (context, fromx, fromy, tox, toy) {
        var headlen = 10; // length of head in pixels
        var dx = tox - fromx;
        var dy = toy - fromy;
        var angle = Math.atan2(dy, dx);
        context.moveTo(fromx, fromy);
        context.lineTo(tox, toy);
        context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
        context.moveTo(tox, toy);
        context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
    }

    return FlowChartVizWidget;
});
